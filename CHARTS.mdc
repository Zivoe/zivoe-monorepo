# Zivoe Charts Documentation

## Overview

This documentation provides comprehensive patterns and examples for creating charts in the Zivoe monorepo using Recharts and custom UI components.

### Architecture
- **Library**: Recharts (composable React charting library)
- **UI Wrapper**: Custom ChartContainer, ChartTooltip, ChartTooltipContent from `@zivoe/ui/core/chart`
- **Styling**: Tailwind CSS with custom design tokens
- **Data Processing**: Viem for BigInt/ether formatting, custom utils for number formatting

### Import Pattern
```typescript
import { 
  AreaChart, LineChart, BarChart, PieChart, ComposedChart,
  CartesianGrid, XAxis, YAxis, Legend, Tooltip,
  Area, Line, Bar, Pie, Cell,
  ResponsiveContainer, Brush, ReferenceLine, ReferenceArea
} from 'recharts';
import { ChartContainer, ChartTooltip, ChartTooltipContent } from '@zivoe/ui/core/chart';
import { customNumber } from '@/lib/utils';
import { formatEther } from 'viem';
```

## 1. Area Chart

### Basic Implementation (Based on deposit-charts.tsx)
```typescript
'use client';

import { useState } from 'react';
import { Key } from 'react-aria-components';
import { useMediaQuery } from 'react-responsive';
import { AreaChart, CartesianGrid, Area as ReArea, XAxis, YAxis } from 'recharts';
import { ChartContainer, ChartTooltip, ChartTooltipContent } from '@zivoe/ui/core/chart';

interface ChartData {
  day: string;
  value: number;
}

export default function CustomAreaChart({ data }: { data: ChartData[] }) {
  const isMobile = useMediaQuery({ query: '(max-width: 599px)' });

  return (
    <ChartContainer config={{}}>
      <AreaChart 
        accessibilityLayer 
        data={data} 
        margin={{ left: 10, right: 0, top: 0, bottom: 0 }}
      >
        <CartesianGrid vertical={false} />
        
        <XAxis
          dataKey="day"
          tickLine={false}
          axisLine={false}
          minTickGap={32}
          tickFormatter={(value) => value.replace(/\s\d{4}$/, '')}
        />
        
        <YAxis
          tickLine={false}
          hide={isMobile}
          axisLine={false}
          tickMargin={16}
          scale="linear"
          domain={[0, 'auto']} // or specific [min, max]
          tickFormatter={(value) => customNumber(value)}
        />
        
        <ChartTooltip
          cursor={false}
          content={
            <ChartTooltipContent
              indicator="dot"
              hideLabel
              formatter={(value, _, item) => (
                <div className="flex flex-col gap-1">
                  <span className="font-heading text-regular tabular-nums text-primary">
                    ${customNumber(Number(value), 2)}
                  </span>
                  <span className="text-small text-secondary">{item.payload.day}</span>
                </div>
              )}
            />
          }
        />
        
        <defs>
          <linearGradient id="fillArea" x1="0" y1="0" x2="0" y2="1">
            <stop offset="39.55%" stopColor="hsl(var(--primary-600))" stopOpacity={0.1} />
            <stop offset="100.17%" stopColor="hsl(var(--primary-600))" stopOpacity={0.0} />
          </linearGradient>
        </defs>
        
        <ReArea 
          dataKey="value" 
          type="linear" 
          fill="url(#fillArea)" 
          stroke="hsl(var(--primary-600))" 
        />
      </AreaChart>
    </ChartContainer>
  );
}
```

### Multiple Areas
```typescript
<AreaChart data={data}>
  <ReArea dataKey="uv" stackId="1" stroke="#8884d8" fill="#8884d8" />
  <ReArea dataKey="pv" stackId="1" stroke="#82ca9d" fill="#82ca9d" />
  <ReArea dataKey="amt" stackId="1" stroke="#ffc658" fill="#ffc658" />
</AreaChart>
```

## 2. Line Chart

### Basic Line Chart
```typescript
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Legend } from 'recharts';

export default function CustomLineChart({ data }: { data: any[] }) {
  return (
    <ChartContainer config={{}}>
      <LineChart 
        width={730} 
        height={250} 
        data={data}
        margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
      >
        <CartesianGrid strokeDasharray="3 3" />
        <XAxis dataKey="name" />
        <YAxis />
        <ChartTooltip 
          content={<ChartTooltipContent indicator="line" />} 
        />
        <Legend />
        <Line type="monotone" dataKey="pv" stroke="#8884d8" activeDot={{ r: 8 }} />
        <Line type="monotone" dataKey="uv" stroke="#82ca9d" />
      </LineChart>
    </ChartContainer>
  );
}
```

### Line Chart with Custom Dots
```typescript
<Line 
  type="monotone" 
  dataKey="value" 
  stroke="#8884d8"
  strokeWidth={2}
  dot={{ fill: '#8884d8', strokeWidth: 2, r: 4 }}
  activeDot={{ r: 8 }}
/>
```

## 3. Bar Chart

### Basic Bar Chart
```typescript
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Legend } from 'recharts';

export default function CustomBarChart({ data }: { data: any[] }) {
  return (
    <ChartContainer config={{}}>
      <BarChart 
        width={600} 
        height={300} 
        data={data}
        margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
      >
        <CartesianGrid strokeDasharray="3 3" />
        <XAxis dataKey="name" />
        <YAxis />
        <ChartTooltip content={<ChartTooltipContent />} />
        <Legend />
        <Bar dataKey="pv" fill="#8884d8" />
        <Bar dataKey="uv" fill="#82ca9d" />
      </BarChart>
    </ChartContainer>
  );
}
```

### Stacked Bar Chart
```typescript
<BarChart data={data}>
  <Bar dataKey="uv" stackId="a" fill="#8884d8" />
  <Bar dataKey="pv" stackId="a" fill="#82ca9d" />
  <Bar dataKey="amt" stackId="a" fill="#ffc658" />
</BarChart>
```

### Custom Bar Shape
```typescript
const CustomBar = (props: any) => {
  const { fill, x, y, width, height } = props;
  
  return (
    <g>
      <rect x={x} y={y} width={width} height={height} fill={fill} rx={4} />
    </g>
  );
};

<Bar dataKey="value" fill="#8884d8" shape={<CustomBar />} />
```

## 4. Pie Chart

### Basic Pie Chart
```typescript
import { PieChart, Pie, Cell, Tooltip, Legend } from 'recharts';

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042'];

export default function CustomPieChart({ data }: { data: any[] }) {
  return (
    <ChartContainer config={{}}>
      <PieChart width={400} height={400}>
        <Pie
          data={data}
          cx={200}
          cy={200}
          labelLine={false}
          label={renderCustomizedLabel}
          outerRadius={80}
          fill="#8884d8"
          dataKey="value"
        >
          {data.map((entry, index) => (
            <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
          ))}
        </Pie>
        <ChartTooltip content={<ChartTooltipContent />} />
      </PieChart>
    </ChartContainer>
  );
}

const renderCustomizedLabel = ({
  cx, cy, midAngle, innerRadius, outerRadius, percent
}: any) => {
  const radius = innerRadius + (outerRadius - innerRadius) * 0.5;
  const x = cx + radius * Math.cos(-midAngle * Math.PI / 180);
  const y = cy + radius * Math.sin(-midAngle * Math.PI / 180);

  return (
    <text 
      x={x} 
      y={y} 
      fill="white" 
      textAnchor={x > cx ? 'start' : 'end'} 
      dominantBaseline="central"
    >
      {`${(percent * 100).toFixed(0)}%`}
    </text>
  );
};
```

## 5. Composed Chart

### Combining Line and Bar
```typescript
import { ComposedChart, Line, Area, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend } from 'recharts';

export default function CustomComposedChart({ data }: { data: any[] }) {
  return (
    <ChartContainer config={{}}>
      <ComposedChart
        width={730}
        height={250}
        data={data}
        margin={{ top: 20, right: 20, bottom: 20, left: 20 }}
      >
        <CartesianGrid stroke="#f5f5f5" />
        <XAxis dataKey="name" />
        <YAxis />
        <ChartTooltip content={<ChartTooltipContent />} />
        <Legend />
        <Area type="monotone" dataKey="amt" fill="#8884d8" stroke="#8884d8" />
        <Bar dataKey="pv" barSize={20} fill="#413ea0" />
        <Line type="monotone" dataKey="uv" stroke="#ff7300" />
      </ComposedChart>
    </ChartContainer>
  );
}
```

## 6. Advanced Features

### Responsive Container
```typescript
<ResponsiveContainer width="100%" height={400}>
  <LineChart data={data}>
    {/* chart content */}
  </LineChart>
</ResponsiveContainer>
```

### Brush for Zooming
```typescript
import { Brush } from 'recharts';

<AreaChart data={data}>
  {/* other components */}
  <Brush 
    dataKey="name" 
    height={30} 
    stroke="#8884d8"
    startIndex={0}
    endIndex={data.length - 1}
  />
</AreaChart>
```

### Reference Lines and Areas
```typescript
import { ReferenceLine, ReferenceArea } from 'recharts';

<LineChart data={data}>
  {/* other components */}
  <ReferenceLine y={200} label="Target" stroke="red" />
  <ReferenceArea y1={200} y2={300} stroke="red" fill="red" fillOpacity={0.1} />
</LineChart>
```

### Custom Legend
```typescript
const renderLegend = (props: any) => {
  const { payload } = props;
  
  return (
    <ul className="flex gap-4 justify-center mt-4">
      {payload.map((entry: any, index: number) => (
        <li key={`item-${index}`} className="flex items-center gap-2">
          <span 
            className="w-3 h-3 rounded-full" 
            style={{ backgroundColor: entry.color }}
          />
          <span className="text-sm">{entry.value}</span>
        </li>
      ))}
    </ul>
  );
};

<Legend content={renderLegend} />
```

## 7. Data Processing Patterns

### Working with BigInt Data (from portfolio/component.tsx)
```typescript
// Best practice: Keep BigInt values in their original form
// Store both BigInt and formatted string versions if needed
interface Snapshot {
  timestamp: Date;
  balance: bigint;        // Original BigInt for calculations
  balanceStr: string;     // String version for chart display
}

const usePortfolio = () => {
  return useQuery({
    queryFn: async () => {
      const portfolio = await fetchPortfolioData();
      
      return {
        value: BigInt(portfolio.data.value),
        snapshots: portfolio.data.snapshots.map((snapshot) => {
          const timestamp = new Date(Number(snapshot.timestamp) * 1000);
          const balanceStr = snapshot.balance;  // Keep as string for chart
          const balance = BigInt(balanceStr);   // Convert for calculations
          
          return { timestamp, balanceStr, balance };
        })
      };
    }
  });
};
```

### Calculating Percentage Changes with BigInt
```typescript
// Correct way to calculate percentages with BigInt
function calculatePortfolioChange({ snapshots }: { snapshots: Snapshots }) {
  const firstBalance = snapshots[0]?.balance;
  const lastBalance = snapshots[snapshots.length - 1]?.balance;
  if (!firstBalance || firstBalance === 0n || !lastBalance) return null;

  // Multiply by 10^4 first to preserve precision (gives percentage * 100)
  const change = ((lastBalance - firstBalance) * 10n ** 4n) / firstBalance;
  const isPositive = change >= 0n;

  return { value: change, isPositive };
}

// Display the percentage
<span>{(Number(change.value) / 100).toFixed(2)}%</span>
```

### Parse Chart Data (from deposit-charts.tsx)
```typescript
interface DailyData {
  timestamp: number;
  tvl: string;
  apy: number;
  indexPrice: number;
}

const parseChartData = (dailyData: DailyData[], type: string) => {
  const data = dailyData.map((item) => {
    const date = new Date(item.timestamp);
    const day = date.getUTCDate();
    const month = date.toLocaleString('en-US', { month: 'short', timeZone: 'UTC' });
    const year = date.getUTCFullYear();

    let value: number | undefined;
    if (type === 'Index price') value = item.indexPrice;
    else if (type === 'TVL') value = Number(formatEther(BigInt(item.tvl)));
    else value = item.apy;

    return {
      day: `${day} ${month} ${year}`,
      data: value
    };
  });

  const currentValue = dailyData[dailyData.length - 1];
  
  return { data, currentValue, type };
};
```

### Network-Specific Configuration
```typescript
import type { Network } from '@zivoe/contracts';

const CHART_CONFIG: Record<Network, Record<string, [number, number]>> = {
  MAINNET: {
    'Index price': [0.99, 1.02],
    TVL: [5_000_000, 10_000_000],
    APY: [10, 35]
  },
  SEPOLIA: {
    'Index price': [0, 2_000],
    TVL: [70_000_000, 100_000_000],
    APY: [16, 24]
  }
};

// Usage
domain={CHART_CONFIG[env.NEXT_PUBLIC_NETWORK][chartType]}
```

## 8. Optimized Chart Patterns (from portfolio/component.tsx)

### Direct Data Usage Without Transformation
```typescript
// Instead of mapping data to new structure
const chartData = snapshots.map(s => ({
  value: s.balanceFormatted,
  date: s.timestamp
}));

// Use data directly with proper dataKey
<AreaChart data={portfolio.snapshots}>
  <XAxis dataKey="timestamp" />
  <ReArea dataKey="balanceStr" />
</AreaChart>
```

### Fixed Height Charts
```typescript
// Override aspect-video with fixed height
<div className="h-[288px] w-full [&>div]:!aspect-auto [&>div]:h-full">
  <ChartContainer config={{}}>
    <AreaChart data={data}>
      {/* chart content */}
    </AreaChart>
  </ChartContainer>
</div>
```

### Accessing Original Data in Tooltips
```typescript
<ChartTooltipContent
  formatter={(_, __, item) => {
    // Access original BigInt value from payload
    const balance = item.payload.balance;  // BigInt
    const timestamp = item.payload.timestamp;  // Date
    
    return (
      <div>
        <span>${formatBigIntWithCommas({ value: balance })}</span>
        <span>{timestamp.toLocaleDateString('en-US', {...})}</span>
      </div>
    );
  }}
/>
```

### Domain Padding with Functions
```typescript
// Add 2% padding to Y-axis boundaries
<YAxis
  domain={[
    (dataMin: number) => dataMin * 0.98,
    (dataMax: number) => dataMax * 1.02
  ]}
/>
```

### Mobile-Responsive Patterns
```typescript
import { useIsMobile } from '@/hooks/useIsMobile';

function Chart() {
  const isMobile = useIsMobile();
  
  return (
    <AreaChart>
      <YAxis hide={isMobile} />
      <XAxis minTickGap={isMobile ? 64 : 32} />
    </AreaChart>
  );
}
```

## 9. Custom Tooltip Patterns

### Multi-Value Tooltip
```typescript
<ChartTooltipContent
  formatter={(value, name, item, index) => (
    <div className="space-y-1">
      <div className="font-semibold">{name}</div>
      <div className="text-sm">
        Value: {customNumber(value)}
      </div>
      <div className="text-xs text-gray-500">
        Change: {item.payload.change}%
      </div>
    </div>
  )}
/>
```

### Conditional Formatting
```typescript
formatter={(value, _, item) => {
  const isPositive = value > 0;
  return (
    <span className={isPositive ? 'text-green-600' : 'text-red-600'}>
      {isPositive ? '+' : ''}{customNumber(value, 2)}%
    </span>
  );
}}
```

## 10. TypeScript Interfaces

### Chart Data Types
```typescript
interface ChartDataPoint {
  name: string;
  value: number;
  [key: string]: any;
}

// Portfolio-specific data structure with BigInt
interface PortfolioSnapshot {
  timestamp: Date;
  balance: bigint;      // For calculations
  balanceStr: string;   // For chart display
}

interface ChartProps<T = ChartDataPoint> {
  data: T[];
  width?: number;
  height?: number;
  margin?: {
    top?: number;
    right?: number;
    bottom?: number;
    left?: number;
  };
}

interface TooltipProps {
  active?: boolean;
  payload?: any[];
  label?: string;
}

// Type-safe hook return types
type Portfolio = Awaited<ReturnType<typeof usePortfolio>>['data'];
type Snapshots = NonNullable<Portfolio>['snapshots'];
```

## 11. Complete Chart Component Template

```typescript
'use client';

import { useState, useMemo } from 'react';
import { useMediaQuery } from 'react-responsive';
import { 
  AreaChart, LineChart, BarChart,
  CartesianGrid, XAxis, YAxis, Legend,
  Area, Line, Bar
} from 'recharts';
import { ChartContainer, ChartTooltip, ChartTooltipContent } from '@zivoe/ui/core/chart';
import { customNumber } from '@/lib/utils';

interface ChartData {
  date: string;
  value: number;
  category?: string;
}

interface ChartComponentProps {
  data: ChartData[];
  type?: 'area' | 'line' | 'bar';
  height?: number;
  showLegend?: boolean;
  domain?: [number | 'auto', number | 'auto'];
}

export default function ChartComponent({ 
  data, 
  type = 'area',
  height = 300,
  showLegend = false,
  domain = ['auto', 'auto']
}: ChartComponentProps) {
  const isMobile = useMediaQuery({ query: '(max-width: 599px)' });
  
  const ChartType = useMemo(() => {
    switch(type) {
      case 'line': return LineChart;
      case 'bar': return BarChart;
      default: return AreaChart;
    }
  }, [type]);

  const DataComponent = useMemo(() => {
    switch(type) {
      case 'line': return Line;
      case 'bar': return Bar;
      default: return Area;
    }
  }, [type]);

  return (
    <ChartContainer config={{}}>
      <ChartType 
        data={data} 
        height={height}
        margin={{ left: isMobile ? 0 : 10, right: 0, top: 10, bottom: 10 }}
      >
        <CartesianGrid 
          vertical={false} 
          strokeDasharray={type === 'bar' ? '3 3' : undefined}
        />
        
        <XAxis
          dataKey="date"
          tickLine={false}
          axisLine={false}
          tickMargin={8}
          minTickGap={isMobile ? 64 : 32}
        />
        
        <YAxis
          tickLine={false}
          axisLine={false}
          hide={isMobile}
          domain={domain}
          tickFormatter={(value) => customNumber(value)}
        />
        
        <ChartTooltip
          cursor={type === 'bar' ? { fill: 'rgba(0,0,0,0.1)' } : false}
          content={
            <ChartTooltipContent
              indicator={type === 'line' ? 'line' : 'dot'}
              hideLabel={!showLegend}
            />
          }
        />
        
        {showLegend && <Legend />}
        
        {type === 'area' && (
          <>
            <defs>
              <linearGradient id="gradient" x1="0" y1="0" x2="0" y2="1">
                <stop offset="5%" stopColor="hsl(var(--primary-600))" stopOpacity={0.3} />
                <stop offset="95%" stopColor="hsl(var(--primary-600))" stopOpacity={0} />
              </linearGradient>
            </defs>
            <Area
              dataKey="value"
              type="monotone"
              fill="url(#gradient)"
              stroke="hsl(var(--primary-600))"
              strokeWidth={2}
            />
          </>
        )}
        
        {type === 'line' && (
          <Line
            dataKey="value"
            type="monotone"
            stroke="hsl(var(--primary-600))"
            strokeWidth={2}
            dot={false}
            activeDot={{ r: 6 }}
          />
        )}
        
        {type === 'bar' && (
          <Bar
            dataKey="value"
            fill="hsl(var(--primary-600))"
            radius={[4, 4, 0, 0]}
          />
        )}
      </ChartType>
    </ChartContainer>
  );
}
```

## 12. Utility Functions

### Number Formatting
```typescript
// From your utils
export const customNumber = (value: number, decimals: number = 0): string => {
  if (value >= 1_000_000_000) {
    return `${(value / 1_000_000_000).toFixed(decimals)}B`;
  } else if (value >= 1_000_000) {
    return `${(value / 1_000_000).toFixed(decimals)}M`;
  } else if (value >= 1_000) {
    return `${(value / 1_000).toFixed(decimals)}K`;
  }
  return value.toFixed(decimals);
};
```

### Date Formatting
```typescript
// Modern, cleaner approach using toLocaleDateString
export const formatChartDate = (date: Date): string => {
  return date.toLocaleDateString('en-US', { 
    day: 'numeric', 
    month: 'short', 
    year: 'numeric',
    timeZone: 'UTC'
  });
};

// Different formats for different contexts
// X-axis labels (compact): "15 Jun"
tickFormatter={(value) =>
  value.toLocaleDateString('en-US', {
    day: 'numeric',
    month: 'short',
    timeZone: 'UTC'
  })
}

// Tooltips (full date): "15 Jun 2025"
const formattedDate = timestamp.toLocaleDateString('en-US', {
  day: 'numeric',
  month: 'short',
  year: 'numeric',
  timeZone: 'UTC'
});
```

### BigInt/Ether Conversion
```typescript
import { formatEther, parseEther } from 'viem';

// Convert BigInt to number
const tvlNumber = Number(formatEther(BigInt(tvlString)));

// Convert number to BigInt
const tvlBigInt = parseEther(tvlNumber.toString());
```

## 13. Performance Optimization

### Memoization
```typescript
import { useMemo } from 'react';

const chartData = useMemo(() => 
  rawData.map(item => ({
    date: formatChartDate(item.timestamp),
    value: processValue(item.value)
  })), 
  [rawData]
);
```

### Lazy Loading
```typescript
import dynamic from 'next/dynamic';

const ChartComponent = dynamic(
  () => import('./ChartComponent'),
  { 
    ssr: false,
    loading: () => <div>Loading chart...</div>
  }
);
```

### Throttling Updates
```typescript
import { throttle } from 'lodash';

const handleChartUpdate = useMemo(
  () => throttle((newData: any) => {
    setChartData(newData);
  }, 100),
  []
);
```

## 14. Accessibility

### ARIA Labels
```typescript
<AreaChart 
  accessibilityLayer 
  data={data}
  role="img"
  aria-label="Chart showing price trends over time"
>
```

### Keyboard Navigation
```typescript
<ChartTooltip 
  isAnimationActive={false}
  allowEscapeViewBox={{ x: false, y: false }}
/>
```

## 15. Common Issues & Solutions

### Issue: Chart not responsive
```typescript
// Wrap in ResponsiveContainer
<ResponsiveContainer width="100%" height={300}>
  <LineChart data={data}>
    {/* content */}
  </LineChart>
</ResponsiveContainer>
```

### Issue: Tooltip cut off
```typescript
<ChartTooltip 
  allowEscapeViewBox={{ x: true, y: true }}
  wrapperStyle={{ zIndex: 1000 }}
/>
```

### Issue: Labels overlapping
```typescript
<XAxis
  dataKey="name"
  interval="preserveStartEnd"
  minTickGap={50}
  angle={-45}
  textAnchor="end"
/>
```

## 16. Filling Missing Data in Time Series

### Simplified Pattern for Interpolating Missing Days
```typescript
function fillMissingDays(snapshots: Array<Snapshot>) {
  if (snapshots.length === 0) return [];

  const firstSnapshot = snapshots[0];
  if (!firstSnapshot) return [];
  
  const result: Array<Snapshot> = [];
  const endDate = getEndOfDayUTC(new Date());
  
  let currentDay = getEndOfDayUTC(firstSnapshot.timestamp);
  let apiIndex = 0;
  let lastBalance = firstSnapshot.balance;
  let lastBalanceStr = firstSnapshot.balanceStr;

  while (currentDay <= endDate) {
    const apiSnapshot = snapshots[apiIndex];
    
    // Check if API snapshot matches current day
    const isMatchingDay = apiSnapshot && 
      getStartOfDayUTC(apiSnapshot.timestamp).getTime() === 
      getStartOfDayUTC(currentDay).getTime();
    
    if (isMatchingDay) {
      // Update to API snapshot values
      lastBalance = apiSnapshot.balance;
      lastBalanceStr = apiSnapshot.balanceStr;
      apiIndex++;
    }
    
    // Always push a snapshot (API or interpolated)
    result.push({
      timestamp: getEndOfDayUTC(currentDay),
      balance: lastBalance,
      balanceStr: lastBalanceStr
    });
    
    // Move to next day
    currentDay = new Date(currentDay);
    currentDay.setUTCDate(currentDay.getUTCDate() + 1);
  }

  return result;
}
```

### Key Principles
1. **Single Push Point**: Always push exactly one snapshot per iteration
2. **Conditional Update**: Only update last known values when finding a match
3. **Forward-Only Iteration**: Process API snapshots sequentially without backtracking
4. **Consistent Timestamps**: Normalize all timestamps to end of day UTC

## 17. Best Practices & Lessons Learned

### Data Structure Best Practices
1. **Keep Original Data Types**: Store BigInt values alongside formatted versions
2. **Avoid Unnecessary Transformations**: Use data directly with proper dataKey attributes
3. **Separate Display from Calculation**: Keep BigInt for calculations, strings/numbers for display

### Performance Optimizations
1. **Use Direct Data Access**: Pass arrays directly to charts without intermediate mapping
2. **Memoize Expensive Calculations**: Only recalculate when dependencies change
3. **Lazy Load Charts**: Use dynamic imports for better initial page load

### BigInt Handling
1. **Never use regular division** with BigInt for percentages - multiply first
2. **Store both formats** when needed (BigInt for calculations, string for display)
3. **Use proper conversion** functions (formatEther, parseEther from viem)

### Styling Patterns
1. **Fixed Heights**: Override aspect-video with `h-[288px] [&>div]:!aspect-auto [&>div]:h-full`
2. **Mobile Responsiveness**: Use `useIsMobile` hook to conditionally hide/adjust elements
3. **Gradient Fills**: Define gradients in `<defs>` and reference with `url(#id)`

### Date Handling
1. **Use toLocaleDateString**: Cleaner than manual date formatting
2. **Different Formats for Context**: Compact for axes, full for tooltips
3. **Always specify timezone**: Use `timeZone: 'UTC'` for consistency
4. **Fill missing days in time series**: Interpolate missing data points to ensure continuous charts

### TypeScript Patterns
1. **Type-safe Hook Returns**: Use `Awaited<ReturnType<typeof hook>>['data']`
2. **Optional Chaining**: Use `?.` for safe property access
3. **Nullish Coalescing**: Use `??` for default values

## Quick Reference

### Chart Types
- `AreaChart` - For trends over time with filled area
- `LineChart` - For trends without fill
- `BarChart` - For categorical comparisons
- `PieChart` - For part-to-whole relationships
- `ComposedChart` - For combining multiple chart types
- `RadarChart` - For multivariate data
- `RadialBarChart` - For circular bar charts
- `ScatterChart` - For correlation analysis

### Common Props
- `data` - Array of data objects
- `width/height` - Dimensions (or use ResponsiveContainer)
- `margin` - Spacing around chart
- `domain` - Y-axis range [min, max] or functions
- `type` - Line/area type: 'linear', 'monotone', 'step'
- `stroke` - Line color
- `fill` - Fill color
- `strokeWidth` - Line thickness
- `dot` - Show/hide dots on lines
- `dataKey` - Property name to access in data objects

### Tooltip Indicators
- `"dot"` - Circular indicator
- `"line"` - Vertical line indicator  
- `"dashed"` - Dashed line indicator

### Formatter Parameters
- `formatter={(value, name, item, index) => ReactNode}`
  - `value` - The data value for the dataKey
  - `name` - The name/key of the data series
  - `item` - Full payload object with access to all data
  - `index` - Index in the data array

This documentation provides all patterns needed to create charts in your Zivoe application. Use these examples as templates and adapt them to your specific requirements.